{"version":3,"sources":["../../src/scripts/draw.js"],"names":["draw","ctx","fillStyle","fillRect","WIDTH","HEIGHT","point","rotated","projected","points","Array","FIGURE","length","i","Matrix","from","transpose","identity","DIMENSION","j","ROTATIONS","dot","getRotationMatrix","angle","perspective","ISOMETRIC","DISTANCE","getProjectionMatrix","scale","SCALING","drawVertices","connectVertices","SPEED","NEXTFRAME","requestAnimationFrame","beginPath","arc","Math","PI","fill","dimension","step","pow","size","connect","i1","i2","moveTo","lineTo","strokeStyle","stroke"],"mappings":"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","file":"draw.js","sourcesContent":["/*\r\nProject from any dimension in 2D using perspective\r\n*/\r\n\r\n//\r\n// Rendering\r\n//\r\n\r\nfunction draw() {\r\n\t// Clear the screen\r\n\tctx.fillStyle = '#fff'\r\n\tctx.fillRect(-WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT)\r\n\r\n\tlet point, rotated, projected\r\n\tlet points = new Array(FIGURE.length)\r\n\r\n\t// Rotating, projecting the vertices, and storing them\r\n\tfor (let i=0; i<FIGURE.length; i++) {\r\n\t\tpoint = Matrix.from([FIGURE[i]])\r\n\t\tpoint = Matrix.transpose(point)\r\n\r\n\t\t/*\r\n\t\tNote: Here I'm combining the rotation matrices by dotting them\r\n\t\tStarting out with the identity matrix, this has the effect of leaving the point intact\r\n\t\tif there are no rotations\r\n\t\t*/\r\n\r\n\t\trotated = Matrix.identity(DIMENSION)\r\n\t\tfor (let j=0; j<ROTATIONS.length; j++) {\r\n\t\t\trotated = Matrix.dot(rotated, getRotationMatrix[DIMENSION-1][ROTATIONS[j]](angle))\r\n\t\t}\r\n\t\trotated = Matrix.dot(rotated, point)\r\n\t\t\r\n\t\t/*\r\n\t\tNote: If you are using more sophisticated projection matrices,\r\n\t\tyou'll need to do 2D · 3D · ... · nD all the way\r\n\t\tBecause we are only using identity matrices (of which one is scaled),\r\n\t\twe can ignore these steps\r\n\t\tWe are projecting\r\n\t\t\t- from 4D into 3D with perspective\r\n\t\t\t- from 3D into 2D orthogonally\r\n\t\t*/\r\n\r\n\t\tlet perspective\r\n\t\tif (ISOMETRIC) {\r\n\t\t\tperspective = 1 \r\n\t\t} else {\r\n\t\t\tperspective = 1/(DISTANCE - rotated[DIMENSION-1][0])\r\n\t\t}\r\n\t\tprojected = getProjectionMatrix(DIMENSION, perspective)\r\n\t\tprojected = Matrix.dot(projected, rotated)\r\n\t\tprojected = Matrix.scale(projected, SCALING)\r\n\r\n\t\tpoints[i] = [projected[0][0], projected[1][0]]\r\n\t}\r\n\r\n\tdrawVertices(points)\r\n\tconnectVertices(points)\r\n\r\n\tangle += SPEED\r\n\r\n\tNEXTFRAME = requestAnimationFrame(draw)\r\n}\r\n\r\n\r\nfunction drawVertices(points) {\r\n\t// Pretty self-explanatory\r\n\tfor (let i=0; i<points.length; i++) {\r\n\t\tctx.beginPath()\r\n\t\tctx.arc(points[i][0], points[i][1], 3, 0, 2*Math.PI)\r\n\t\tctx.fillStyle = '#000'\r\n\t\tctx.fill()\r\n\t}\r\n}\r\n\r\n\r\nfunction connectVertices(points) {\r\n\t/*\r\n\tHere is the pattern to connect the vertices correctly\r\n\tThis works for every dimension starting from 1D (2 vertices, connect them together)\r\n\t\t- every 2 points (i%2 === 0): for the next 1 point: connect i and i+1\r\n\t\t- every 4 points (i%4 === 0): for the next 2 points: connect i and i+2\r\n\t\t- every 8 points (i%8 === 0): for the next 4 points: connect i and i+4\r\n\t\t- every 16 points (i%16 === 0): for the next 8 points: connect i and i+8\r\n\t\t- ...\r\n\t\t- every 2^{dimensions}: for the next 2^{dimensions+!}: connect i and i+2^{dimensions-1}\r\n\tI'm calling the every ... points the step, and the number points each step the size  \r\n\t*/\r\n\r\n\tctx.beginPath()\r\n\r\n\tfor (let dimension=1; dimension<DIMENSION+1; dimension++) {\r\n\t\tlet step = Math.pow(2, dimension)\r\n\t\tlet size = Math.pow(2, dimension-1)\r\n\t\tfor (let i=0; i<points.length; i+=step) {\r\n\t\t\tfor (let j=0; j<size; j++) {\r\n\t\t\t\tconnect(i+j, i+j+size)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction connect(i1, i2) {\r\n\t\tctx.moveTo(points[i1][0], points[i1][1])\r\n\t\tctx.lineTo(points[i2][0], points[i2][1])\r\n\t}\r\n\r\n\tctx.strokeStyle = '#000'\r\n\tctx.stroke()\r\n}"]}